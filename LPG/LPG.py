import os
import qt
import slicer
import vtk
from slicer.ScriptedLoadableModule import *
import numpy as np

class LPG(ScriptedLoadableModule):
    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        parent.title = "LPG"
        parent.categories = ["MCNP"]
        parent.dependencies = []
        parent.contributors = ["Harlley Haurado, Pala Salvatice, Mirta Berdeguez e Ademir da Silva"] # Substitua pelo seu nome
        parent.helpText = """This plugin generate a mash phantom from a 3D imagem for MCNP code called phantom.inp"""
        parent.acknowledgementText = """""" # Deixe vazio ou adicione créditos

class LPGWidget(ScriptedLoadableModuleWidget):
    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        uiWidget = slicer.util.loadUI(self.resourcePath('UI/LPG.ui'))
        self.layout.addWidget(uiWidget)
        self.ui = slicer.util.childWidgetVariables(uiWidget)
        self.ui.generateButton.connect('clicked(bool)', self.onGenerateButtonClicked)

    def resourcePath(self, filename):
        return os.path.join(os.path.dirname(__file__), 'Resources', filename)

    def onGenerateButtonClicked(self):
        segmentationNode = slicer.util.getNode('Segmentation')
        if not segmentationNode:
            slicer.util.errorDisplay("Segmentação não encontrada.")
            return

        saveDirectory = qt.QFileDialog.getExistingDirectory(None, "Selecione o diretório para salvar o arquivo phantom.inp")
        if not saveDirectory:
            slicer.util.errorDisplay("Nenhum diretório selecionado.")
            return

        voxelArray, segmentNames = self.getVoxelData(segmentationNode)
        filePath = os.path.join(saveDirectory, 'phantom.inp')

        if voxelArray is not None:
            self.saveAsMCNPLattice(voxelArray, segmentNames, filePath)
            slicer.util.infoDisplay(f"Arquivo salvo com sucesso em: {filePath}")
        else:
            slicer.util.errorDisplay("Falha ao gerar a matriz de voxels.")

    def getVoxelData(self, segmentationNode):
        """
        Extrai os dados voxel da segmentação como uma matriz numpy e retorna os nomes dos segmentos.
        """
        segmentIds = vtk.vtkStringArray()  # Cria uma nova instância de vtkStringArray
        segmentationNode.GetSegmentation().GetSegmentIDs(segmentIds)

        segmentNames = []
        voxelArray = None

        print(f"Total de segmentos: {segmentIds.GetNumberOfValues()}")  # Debug

        for i in range(segmentIds.GetNumberOfValues()):
            segmentId = segmentIds.GetValue(i)
            segment = segmentationNode.GetSegmentation().GetSegment(segmentId)
            segmentNames.append(segment.GetName())

            # Converter a segmentação atual para um array numpy
            labelmapArray = slicer.util.arrayFromSegmentBinaryLabelmap(segmentationNode, segmentId)
            print(f"Segmento {i} - Nome: {segment.GetName()}, Shape: {labelmapArray.shape}")  # Debug

            if voxelArray is None:
                voxelArray = np.zeros_like(labelmapArray)

            # Preencher voxelArray com o índice do segmento (i+1) onde o valor da labelmapArray é maior que 0
            voxelArray[labelmapArray > 0] = i + 1

        return voxelArray, segmentNames



    def saveAsMCNPLattice(self, voxelArray, segmentNames, file_path):
        with open(file_path, 'w') as file:
            # Cabeçalho e definição da célula lattice
            file.write("c --- Phantom Generated by LPG Plugin ---\n")
            file.write("c --- Cell Cards ---\n")
            file.write("1003 0 -501 502 -503 504 -505 506 lat=1 u=999 imp:p=1 imp:e=1\n")
            file.write(f"     fill=0:{voxelArray.shape[0]-1} 0:{voxelArray.shape[1]-1} 0:{voxelArray.shape[2]-1}\n\n")
            
            # Escrever a matriz voxel slice por slice
            file.write("c --- Lattice Filling ---\n")
            for z in range(voxelArray.shape[2]):
                file.write(f"c --- Slice {z+1} ---\n")
                for x in range(voxelArray.shape[0]):
                    line = ' '.join(map(str, voxelArray[x, :, z]))
                    file.write(line + "\n")
                file.write("\n")
            
            # Definição de materiais e células
            file.write("c --- Material Definitions ---\n")
            file.write("255 200 -1.225e-3 -501 502 -503 504 -505 506 u=255 IMP:P=1 IMP:E=1 $ Air surrounding the phantom\n")
            
            for idx, segmentName in enumerate(segmentNames, start=1):
                file.write(f"{idx} like 255 but mat={idx} rho=-1.09 u={idx} IMP:P=1 IMP:E=1 $ {segmentName}\n")
            
            file.write("\n")
            file.write("c --- Surface Cards ---\n")
            file.write("501 px 0\n502 px {}\n".format(voxelArray.shape[0]))
            file.write("503 py 0\n504 py {}\n".format(voxelArray.shape[1]))
            file.write("505 pz 0\n506 pz {}\n".format(voxelArray.shape[2]))
            
            file.write("\n")
            file.write("c --- Data Cards ---\n")
            file.write("mode p e\n")
            file.write("imp:p 1 255r 0\n")
            file.write("imp:e 1 255r 0\n")
            
            file.write("\n")
            file.write("c --- End of File ---\n")





    # def saveAsMCNPLattice(self, voxelArray, segmentNames, file_path):
    #     with open(file_path, 'w') as file:
    #         # Cabeçalho e definição da célula lattice
    #         file.write("1003 0 -501 502 -503 504 -505 506 lat=1 u=999 imp:p=1 imp:e=1\n")
    #         file.write(f"      fill=0:{voxelArray.shape[0]-1} 0:{voxelArray.shape[1]-1} 0:{voxelArray.shape[2]-1}\n")
    #         file.write("\n")

    #         # Escrever a matriz voxel slice por slice
    #         for z in range(voxelArray.shape[2]):  # Para cada slice na direção z
    #             file.write(f"Slice {z+1}:\n")
    #             for y in range(voxelArray.shape[1]):  # Para cada linha na direção y
    #                 line = ""
    #                 for x in range(voxelArray.shape[0]):  # Para cada coluna na direção x
    #                     line += f"{voxelArray[x, y, z]} "  # Adiciona o ID do voxel na linha
    #                 file.write(line.strip() + "\n")  # Escreve a linha no arquivo
    #             file.write("\n")  # Nova linha após cada slice

    #         # Definição de materiais e células
    #         file.write("255 200 -1.225e-3 -501 502 -503 504 -505 506 u=255 IMP:P = 1 IMP:E =1 $ Ar no entorno do phantom\n")

    #         # Definição dos materiais para cada segmento
    #         for i, segmentName in enumerate(segmentNames, start=1):
    #             file.write(f"{i} like 255 but mat={i} rho=-1.09 u={i} IMP:P = 1 IMP:E =1 $ {segmentName}\n")








    # def saveAsMCNPLattice(self, voxelArray, segmentationNode, file_path):
    #     with open(file_path, 'w') as file:
    #         # Cabeçalho e definição da célula lattice
    #         file.write("1003 0 -501 502 -503 504 -505 506 lat=1 u=999 imp:p=1 imp:e=1\n")
    #         file.write(f"      fill=0:{voxelArray.shape[0]-1} 0:{voxelArray.shape[1]-1} 0:{voxelArray.shape[2]-1}\n")
            
    #         # Preenchimento compactado (exemplo simplificado)
    #         last_value = voxelArray[0, 0, 0]
    #         count = 0
    #         line = "      "
            
            # for z in range(voxelArray.shape[2]):
            #     for y in range(voxelArray.shape[1]):
            #         for x in range(voxelArray.shape[0]):
            #             current_value = voxelArray[x, y, z]
            #             file.write(f'x:{x}, y:{y}, z{z} ')
            #         file.write(f'\n {segmentNames}')
            
            # # Finaliza o preenchimento
            # line += f"{last_value} {count}r "
            # file.write(line + "\n")
            
            # # Definição de materiais e células
            # file.write("\n")
            # file.write("255 200 -1.225e-3 -501 502 -503 504 -505 506 u=255 IMP:P = 1 IMP:E =1 $ Ar no entorno do phantom\n")
            
            # material_map = {
            #     1: "Pele",
            #     2: "Gordura",
            #     4: "Olhos",
            #     5: "Lentes dos olhos",
            #     6: "Músculo",
            #     7: "Cérebro (encéfalo)",
            #     # Adicione outros materiais conforme necessário
            # }
            
            # for material_id, material_name in material_map.items():
            #     file.write(f"{material_id} like 255 but mat={material_id} rho=-1.09 u={material_id} IMP:P = 1 IMP:E =1 $ {material_name}\n")