import os
import qt
import slicer
import vtk
from slicer.ScriptedLoadableModule import *
import numpy as np

class LPG(ScriptedLoadableModule):
    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        parent.title = "LPG"
        parent.categories = ["MCNP"]
        parent.dependencies = []
        parent.contributors = ["Harlley Haurado, Pala Salvatice, Mirta Berdeguez e Ademir da Silva"] # Substitua pelo seu nome
        parent.helpText = """This plugin generate a mash phantom from a 3D imagem for MCNP code called phantom.inp"""
        parent.acknowledgementText = """""" # Deixe vazio ou adicione créditos

class LPGWidget(ScriptedLoadableModuleWidget):
    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        uiWidget = slicer.util.loadUI(self.resourcePath('UI/LPG.ui'))
        self.layout.addWidget(uiWidget)
        self.ui = slicer.util.childWidgetVariables(uiWidget)
        self.ui.generateButton.connect('clicked(bool)', self.onGenerateButtonClicked)

    def resourcePath(self, filename):
        return os.path.join(os.path.dirname(__file__), 'Resources', filename)

    def onGenerateButtonClicked(self):
        segmentationNode = slicer.util.getNode('Segmentation')
        if not segmentationNode:
            slicer.util.errorDisplay("Segmentação não encontrada.")
            return

        saveDirectory = qt.QFileDialog.getExistingDirectory(None, "Selecione o diretório para salvar o arquivo phantom.inp")
        if not saveDirectory:
            slicer.util.errorDisplay("Nenhum diretório selecionado.")
            return

        voxelArray, segmentNames = self.getVoxelData(segmentationNode)
        filePath = os.path.join(saveDirectory, 'phantom.inp')

        if voxelArray is not None:
            self.saveAsMCNPLattice(voxelArray, segmentNames, filePath)
            slicer.util.infoDisplay(f"Arquivo salvo com sucesso em: {filePath}")
        else:
            slicer.util.errorDisplay("Falha ao gerar a matriz de voxels.")

    def getVoxelData(self, segmentationNode):
        """
        Extrai os dados voxel da segmentação como uma matriz numpy e retorna os nomes dos segmentos.
        """
        segmentIds = vtk.vtkStringArray()  # Cria uma nova instância de vtkStringArray
        segmentationNode.GetSegmentation().GetSegmentIDs(segmentIds)

        segmentNames = []
        voxelArray = None

        print(f"Total de segmentos: {segmentIds.GetNumberOfValues()}")  # Debug

        for i in range(segmentIds.GetNumberOfValues()):
            segmentId = segmentIds.GetValue(i)
            segment = segmentationNode.GetSegmentation().GetSegment(segmentId)
            segmentNames.append(segment.GetName())

            # Converter a segmentação atual para um array numpy
            labelmapArray = slicer.util.arrayFromSegmentBinaryLabelmap(segmentationNode, segmentId)
            print(f"Segmento {i} - Nome: {segment.GetName()}, Shape: {labelmapArray.shape}")  # Debug

            if voxelArray is None:
                voxelArray = np.zeros_like(labelmapArray)

            # Preencher voxelArray com o índice do segmento (i+1) onde o valor da labelmapArray é maior que 0
            voxelArray[labelmapArray > 0] = i + 1

        return voxelArray, segmentNames



    def saveAsMCNPLattice(self, voxelArray, segmentNames, file_path):
        with open(file_path, 'w') as file:
            # Cabeçalho e definição da célula lattice
            file.write("c --- Phantom Generated by LPG 3D Slicer Plugin ---\n")
            file.write("c ---       Developed by Harlley Hauradou       ---\n")
            file.write("c --- Cell Cards ---\n")
            file.write("1000 0 -501 502 -503 504 -505 506 lat=1 u=999 imp:p=1 imp:e=1\n")
            file.write(f"     fill=0:{voxelArray.shape[0]-1} 0:{voxelArray.shape[1]-1} 0:{voxelArray.shape[2]-1}\n")
            
            # Escrever a matriz voxel slice por slice
            file.write("c --- Lattice Filling ---\n")
            for z in range(voxelArray.shape[2]):
                for x in range(voxelArray.shape[0]):
                    line = self.compress_line(voxelArray[x, :, z])
                    file.write(line + "\n")
            
            # Definição de materiais e células
            file.write("c --- Universe Definitions ---\n")
            file.write("255 200 -1.225e-3 -501 502 -503 504 -505 506 u=255 IMP:P=1 IMP:E=1 $ Air surrounding the phantom\n")
            
            for idx, segmentName in enumerate(segmentNames, start=1):
                file.write(f"{idx} like 255 but mat={idx} rho=-1.09 u={idx} IMP:P=1 IMP:E=1 $ {segmentName}\n")
            
            file.write("\n")
            file.write("c --- Surface Cards ---\n")
            file.write("501 px 0\n502 px {}\n".format(voxelArray.shape[0]))
            file.write("503 py 0\n504 py {}\n".format(voxelArray.shape[1]))
            file.write("505 pz 0\n506 pz {}\n".format(voxelArray.shape[2]))
            
            file.write("\n")
            file.write("c --- Data Cards ---\n")
            file.write("mode p e\n")
            file.write("imp:p 1 255r 0\n")
            file.write("imp:e 1 255r 0\n")
            
            file.write("\n")
            file.write("c --- End of File ---\n")

    def compress_line(self, row):
        """
        Substitui 0 por 255 e comprime a linha para o formato `valor nr`, onde n é o número de repetições.
        """
        compressed = []
        current_value = 255 if row[0] == 0 else row[0]
        count = 1
        
        for value in row[1:]:
            value = 255 if value == 0 else value
            if value == current_value:
                count += 1
            else:
                if count > 1:
                    compressed.append(f"{current_value} {count}r")
                else:
                    compressed.append(str(current_value))
                current_value = value
                count = 1
        
        # Append the last value
        if count > 1:
            compressed.append(f"{current_value} {count}r")
        else:
            compressed.append(str(current_value))
        
        return ' '.join(compressed)